" TODO: Add settings for if the term is not utf-8
" Vim preferneces file
" Sections:
"   -> Initial
"   -> Plugins
"   -> File Types
"   -> Chained Keybinds
"   -> Meta
"   -> Looks
"   -> Formatting
"   -> Searching
"   -> Msc
"   -> Movement
"   -> Other things


""""""""""""""""""""""""""""""""""" Initial """""""""""""""""""""""""""""""""""
" This isn't Vi, it is Vi IMproved. So lets not cling to old Vi settings
if has('vim_starting')
  set nocompatible
endif
" Remap leader. Needs to be done before any mappings involving the leader.
nnoremap <SPACE> <Nop>
onoremap <SPACE> <Nop>
let mapleader=" "


" Vim looks for plugins in vimfiles instead of .vim in Windows
if has('gui_win32')
  let g:vimDirectory=expand("$HOME/vimfiles")
elseif has('nvim')
  let g:vimDirectory=expand("$HOME/.config/nvim")
else
  let g:vimDirectory=expand("$HOME/.vim")
endif
let g:vimDirectoryPart=expand(g:vimDirectory . "/")
let g:vimDirectory=g:vimDirectory

let g:vimrcDirectory=expand(expand("<sfile>:p:h") . "/")

let g:USE_PLUGINS=0
if empty($NO_VIM_PLUGINS) && filereadable(g:vimrcDirectory . ".vimrc_plugin")
  exec "so " . g:vimrcDirectory . ".vimrc_plugin"
endif

""""""""""""""""""""""""""""""""" File Types """""""""""""""""""""""""""""""""
" How to set filetypes: (an example of setting one as ruby)
" au BufRead,BufNewFile *.rpdf       set ft=ruby
"
augroup UserFileTypeDefs
   autocmd!

  au BufRead,BufFilePre,BufNewFile *.sls set filetype=yaml
  au BufRead,BufFilePre,BufNewFile *.inc set filetype=php
  au BufRead,BufFilePre,BufNewFile *.module set filetype=php
augroup END

augroup RustDoc
  autocmd!
  autocmd FileType rustdoc nnoremap <buffer>q :bd<CR>
augroup END

if executable('ant')
  augroup JavaMakeSettings
    autocmd!
    autocmd FileType java setlocal makeprg=ant\ -find\ 'build.xml'
    autocmd FileType java compiler ant
    autocmd FileType java setlocal shellpipe=2>&1\ \|\ tee
  augroup END
endif
let java_highlight_all=1

augroup FileTypeSpecificCmds
  autocmd!
  " Use the java docs for keyword help
  autocmd FileType java setlocal keywordprg=
  "nnoremap <Leader>ls :w <BAR> !lessc % > ../css/%:t:r.css<CR><space>
  autocmd FileType less setlocal makeprg=lessc\ %\ >\ ../css/%:t:r.css
  autocmd FileType plaintex set ft=tex | syntax enable

  autocmd FileType tex  if ! isdirectory('.LatexOutput') |  exec "!mkdir .LatexOutput" |  endif

  autocmd FileType tex exec "setlocal makeprg=latexmk\\ -outdir=\\\"" . expand('%:p:h') . expand('/') . ".LatexOutput\\\"\\ -pdf\\ %"

  autocmd FileType tex set conceallevel=2

  " Workaround for lack of timer_create in WSL
  if !empty($IN_WSL)
    let s:pandoc="pandoc\\ +RTS\\ -V0\\ -RTS"
    let s:pandocPDF="pandoc +RTS -V0 -RTS"
  else
    let s:pandoc="pandoc"
    let s:pandocPDF="pandoc"
  endif

  autocmd FileType pandoc  if ! isdirectory('.PandocOutput') |  exec "!mkdir .PandocOutput" |  endif
  " autocmd FileType markdown exec "setlocal makeprg=pandoc\\ -s\\ --to=html\\ --output=\\\""
    \ . expand('%:h') . expand('/') . ".PandocOutput" . expand('/') . expand('%:r') . ".html\\\"\\ %"

  " autocmd FileType pandoc exec "setlocal makeprg=pandoc\\ -s\\ --output=\\\"" . expand('%:h') . expand('/')
    \ . ".PandocOutput" . expand('/') . expand('%:r') . ".pdf\\\"\\ %"

  autocmd FileType pandoc exec "setlocal makeprg=" . s:pandoc . "\\ --highlight-style=pygments\\ -s\\ --output=\\\""
    \ . expand('%:h') . expand('/') . ".PandocOutput" . expand('/') . expand('%:r') . ".html\\\"\\ %"

  function! ViewPandoc()
    exec "!cat " . expand('%:h') . expand('/') . ".PandocOutput" . expand('/') . expand('%:r') . ".html \| w3m -T text/html"
  endfunction
  autocmd FileType pandoc command! -nargs=0 -buffer ViewPandoc call ViewPandoc()
  function! PandocMakePDF()
    exec "!" . s:pandocPDF . " --highlight-style=pygments -s --output=\"" . expand('%:h') . expand('/') . ".PandocOutput" . expand('/') . expand('%:r') . ".pdf\" %"
  endfunction
  autocmd FileType pandoc command! -nargs=0 -buffer PandocMakePDF call PandocMakePDF()

  " Turn spellcheck off because we are going to be using words that aren't in the dictionary
  autocmd FileType pandoc setlocal nospell
  " Use 4 spaces per tab since thats the magic number for pandoc
  autocmd FileType pandoc setlocal shiftwidth=4
  " Don't add '*' or '#' after newline
  autocmd FileType pandoc setlocal formatoptions-=r
  autocmd FileType pandoc setlocal formatoptions-=o


  " When editing plain text I don't need to see the ends of lines.
  autocmd FileType txt setlocal wrap linebreak nolist textwidth=0 wrapmargin=0

  autocmd FileType gitcommit set spell
augroup END
" let g:tex_conceal = ""

augroup BufEnterFileTypeCmds
  autocmd!
  autocmd BufEnter *.js setlocal foldmethod=indent
augroup END

"""""""""""""""""""""""""""""""""""" Meta """""""""""""""""""""""""""""""""""""
" Use Control-a to move to normal mode
inoremap kj <Esc>
" Allow the use of a familiar key combination to exit visual mode
vnoremap kj <Esc>
" Toggle paste mode.
set pastetoggle=<F11>
" Makes the switch to paste mode immediately shown
map <F11> :set invpaste paste?<CR>
" Change vim pwd to dir of file to easily open other files in dir
nnoremap <leader>cd :cd %:p:h<CR>
" Fix broken default mappings
nmap dd d_
" We aren't going to have any vim variables at the beginning or end of files
set modelines=1
set modeline
" Turn on wild menu (Allow tab use with the command line)
set wildmenu
" Settings for wildmenu (:h wildmenu)
set wildmode=list:longest,list:full
" Get rid of the help key
inoremap <F1> <Nop>
nnoremap <F1> <Nop>
vnoremap <F1> <Nop>

" Don't redraw while executing macros (good performance config)
set lazyredraw

" Use generic omnicompletion if something more specific isn't already set
"if has("autocmd") && exists("+omnifunc")
    "au Filetype *
        "\ if &omnifunc == "" | setl omnifunc=syntaxcomplete#Complete | endif
"endif

" auto-save on focus loss
" au FocusLost * :wa
" return to last edit position when opening files (you want this!)
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
" Open .vimrc
nmap <leader>ev <c-w><c-s><c-l>:e $MYVIMRC<CR>|:exec "nnoremap <buffer>q :bd\<CR\>"<CR>
" Open a scratch buffer
nmap <leader>cs :new|:set buftype=nofile<CR>|:setlocal noswapfile<CR>|:exec "nnoremap <buffer>q :bd\<CR\>"<CR>|:exe "resize " . (winheight(0) * 2 * 1/6)<CR>
" Resize the current buffer
nnoremap <leader>rs :exe "resize " . (winheight(0) * 2 * 5/6)<CR>
  "silent! set buftype=nofile
  "silent! set bufhidden=hide
  "silent! setlocal noswapfile
"""" Meta files
" Create backup, swap, and undo  folders if they do not exist
" Centralize backups, swapfiles and undo history
 if ! isdirectory(g:vimDirectoryPart . 'backups')
  call mkdir(g:vimDirectoryPart . 'backups')
endif
 if ! isdirectory(g:vimDirectoryPart . 'swaps')
  call mkdir(g:vimDirectoryPart . 'swaps')
endif
if has('persistent_undo')
  " Store undo data in a file for persistence between sessions
  if ! isdirectory(g:vimDirectoryPart . 'undo')
    call mkdir(g:vimDirectoryPart . 'undo')
  endif
  exec "set undodir=" . g:vimDirectoryPart . "undo"
  set undofile
endif
exec "set backupdir=" . g:vimDirectoryPart . "backups"
exec "set directory=" . g:vimDirectoryPart . "swaps"

"if has('gui_win32')
"  source $VIMRUNTIME/mswin.vim
"endif
"
" Was in default gVim vimrc
if has('gui') && has('vim_starting')
  set diffexpr=MyDiff()
  function! MyDiff()
    let opt = '-a --binary '
    if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
    if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
    let arg1 = v:fname_in
    if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
    let arg2 = v:fname_new
    if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
    let arg3 = v:fname_out
    if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
    let eq = ''
    if $VIMRUNTIME =~ ' '
      if &sh =~ '\<cmd'
        let cmd = '""' . $VIMRUNTIME . '\diff"'
        let eq = '"'
      else
        let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
      endif
    else
      let cmd = $VIMRUNTIME . '\diff'
    endif
    silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
  endfunction

" Get the args that Vim was opened with
  redir @a
  silent args
  redir END
  " If we are running the GUI and we didn't open a specific file, move to ~ so that
  " we aren't in the folder where Vim was installed to
  if has('gui') && @a == ''
    cd ~
  endif
endif

"""""""""""""""""""""""""""""""""""" Looks """"""""""""""""""""""""""""""""""""
"""" Color Scheme
" If using vimdiff, use a colorscheme that is actually readable.
if &diff
  colorscheme blue
  nmap <leader>. :diffget RE<CR>
  nmap <leader>m :diffget LO<CR>
endif

let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
if has('win32unix') || !empty($IN_WSL)
  let &t_ti.="\e[1 q"
  let &t_SI.="\e[5 q"
  let &t_EI.="\e[1 q"
  let &t_te.="\e[0 q"
endif
" Refresh busted syntax highlighting (this happens too often)
map <F12> :syntax sync fromstart<cr>

if empty($NO_VIM_GUICOLORS) && has("termguicolors")
  set termguicolors
endif

" Don't turn syntax or highlight searching on unless there are enough colors
" to make them look good
if (&t_Co > 2 || has("gui_running") || $TERM =~ '-256color') && has("syntax")
  if !empty($TMUX)
    set t_ut=
  endif
    " Use 256 colors
    set t_Co=256
    " Start vim with solarized theme of the correct flavor
    syntax enable
    if $TERM_COLOR == 'light'
      set background="light"
    else
      set background="dark"
    endif

    if !g:USE_PLUGINS
      silent! colorscheme desert
    elseif empty($NO_VIM_GUICOLORS) && has("termguicolors")
      if $TERM_COLOR == 'light'
        silent! colorscheme solarized8_light
      else
        silent! colorscheme solarized8_dark
      endif
    else
      " Silent so that it doesn't throw an error if the colorscheme doesn't exist
      silent! colorscheme solarized
    endif

    if has("gui_running")
      set guioptions-=T
    endif

    " If we are using a gui set the font in the proper format for that gui
    if has("gui_gtk2")
      set guifont= DejaVu\ Sans\ Mono\ for\ Powerline\ 12
    elseif has("gui_macvim")
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h12
    elseif has("gui_win32")
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h12:cANSI
    endif
endif


" Always use absolute line numbers
set number

" Use relative line numbers if we can
if exists("&relativenumber")
"   " This can cause lag (like when there is no v-sync) when scrolling.
  set relativenumber
endif

" Show on status bar line & column number, relative % in file
set ruler
" Don't display incomplete commands
set noshowcmd
" Shut the fuck up (Screen flashes instead of making a beep)
set visualbell
" Highlight current line (Horizontal underline)
" This caused lag (like when there is no v-sync) when scrolling.
" set cursorline
" No need to show the mode, as airline will show it for us
set noshowmode
" Don't show "ins-completion-menu" messages (shown when auto-completing)
set shortmess+=c
" Always show the status line (I use airline, so I want to see it)
set laststatus=2
" Wrap lines of text that are too long around to the next line
set wrap
" Show column at x chars so that there is no lines to long
if exists('+colorcolumn')
  set colorcolumn=80
endif
" Show the number of changes made when doing substitutions
set report=0
" Show matching brackets when text indicator is over them"
set showmatch
" How long in 1/10s of a second to show the match
set matchtime=5
" Use utf-8 encoding. Needs to be set before listchars on some systems.
set encoding=utf-8
" Show hidden chars
set list
" Set hidden chars to show (Show tabs and trailing spaces)
if &encoding == "utf-8"
  exe "set listchars=eol:\u00ac,nbsp:\u001f,conceal:\u2315,tab:\u2595\u2014,precedes:\u2026,extends:\u2026"
  exe "set sbr=\u21b3"
else
  set listchars=eol:$,trail:-,tab:>-,extends:>,precedes:<,conceal:+
endif
" Turn off lazy redraw
set nolazyredraw
" We are using a fairly fast terminal connection most times
set ttyfast
" When switching buffers, preserve window view.(Vim tip 1375)
if v:version >= 700
  au BufLeave * if !&diff | let b:winview = winsaveview() | endif
  au BufEnter * if exists('b:winview') && !&diff | call winrestview(b:winview) | unlet! b:winview | endif
endif


""""""""""""""""""""""""""""""""" Formatting """"""""""""""""""""""""""""""""""
" Strips excess whitespace from file
nnoremap <leader>w :%s/\s\+$//<CR>:let @/=''<CR>
" Converts existing tabs to spaces
nnoremap <leader>rt :retab<CR>
" Use smart indenting when starting a new line
set smartindent
" Number of spaces to use for auto-indent ('>>' or '<<)
set shiftwidth=2
" Number of spaces a tab in a file counts for
" shiftwidth spaces.
set tabstop=2
" Use an appropriate number of spaces instead of tabs when typing <Tab>
set expandtab
" At start of line, <Tab> inserts shiftwidth spaces, <Bs> deletes
set smarttab
" Align indentation in case block with the label istelf instead of after
" the label.
set cinoptions+=l1
" Align indentation of labels in switch blocks with the switch statement
set cinoptions+=:0
" Align indentation of jump labels in general blocks with the block
set cinoptions+=Ls
" Align new lines in open parenthesis with the first item in the parenthesis
set cinoptions+=(0

" The maximum width of a line of text. Lines that go longer will be broken
" after a whitespace
set textwidth=100
" Sets how vim formats text (see :h fo-table)
set formatoptions=qrno
" Set line ending preferences (CR LR stuff)
set fileformats=unix,dos,mac
" Creates a gutter on the left side ofthe screen showing fold info
" By default do not show the gutter
autocmd FileType * set foldcolumn=0
" Show the gutter for only specified filetypes
autocmd FileType javascript setlocal foldcolumn=6
" Auto include folds based on indent. Syntax-based folds can slow down opening large files.
set foldmethod=indent
" Open files with all folds open by default
set foldlevel=99
" Reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv
" Re-hardwrap paragraph
nnoremap <leader>q gqip


"""""""""""""""""""""""""""""""""" Searching """"""""""""""""""""""""""""""""""
" Clears  the search by pressing <leader> COMMA
nnoremap <silent><leader>, :noh<CR>
set ignorecase             " ignore case when searching
set smartcase
" Use sane regexes
nnoremap / /\v
vnoremap / /\v
nnoremap ? ?\v
vnoremap ? ?\v
set incsearch   " Search incrementally
set hlsearch    " Highlight search matches

" If we have 'live substitution', enable it
if exists('&inccommand')
  set inccommand=split
endif


"""""""""""""""""""""""""""""""""""" Msc. """""""""""""""""""""""""""""""""""""
" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>^m mmHmt:%s/<C-V><CR>//ge<CR>'tzt'm
" Look for tag files in paths relative to cwd, not the file being edited
set cpoptions+=d
" Allow backspacing over everything in insert mode (:h bs)
set backspace=indent,eol,start
" Be smart about case when using autocomplete
set infercase
" Helps if you have to use another editor on the same file
au FileChangedShell * echoerr "File has been changed outside of Vim."
" Specify how keyword completion works
set complete=.,t
set completeopt=longest,menu
" Open new split windows to right and bottom, which feels more natural
set splitbelow
set splitright
" Make Y behave like other capitals
nnoremap Y y$
" Replace a word with yanked text
nnoremap <leader>rp viw"0p
"""" Help
" Press Enter to follow a help tag
au filetype help nnoremap <buffer><CR> <c-]>
" Press Backspace to go back to the location of the previous tag
au filetype help nnoremap <buffer><BS> <c-T>
" Press q to exit the help
au filetype help nnoremap <buffer>q :q<CR>
au filetype help set nonumber
" Displays a list of maps that include the leader
function! ListLeaders()
  silent! redir @b
  silent! nmap <LEADER>
  silent! redir END
  silent! new
  silent! set buftype=nofile
  silent! set bufhidden=delete
  silent! setlocal noswapfile
  silent! put! b
  silent! g/^s*$/d
  silent! %s/^.*,//
  silent! normal ggVg
  silent! sort
  silent! let lines = getline(1,"$")
  silent! normal <esc>
endfunction
command! ListLeaders :call ListLeaders()

" Saves the current file with a datestamp prepended to the name
" If given no args it saves using the current file name
" If given one arg it saves with the given arg as the file name
" If given two args it saves in the directory of the first arg with the second arg as the file name
" If doMove it moves the current file instead of saving a new file
function! DateSaveFunc(bang, doMove, ...)
  echo a:doMove
  if a:0 == 0
    let l:thisPath = expand('%:h')
    if l:thisPath == ''
      echoerr "Cannot add a date to an unnamed file"
      return 0
    else
      let l:newPath = a:bang . ' ' . fnameescape(l:thisPath . expand('/') . strftime('%Y%m%d') . '_' . expand('%:t'))
    endif
  elseif a:0 == 1
    let l:newPath =  a:bang . ' ' . fnameescape(expand('%:h') . expand('/') . strftime('%Y%m%d') . '_' . a:1)
  elseif a:0 == 2
    let l:thisPath = expand(a:1)
    let l:strLen = strchars(l:thisPath) - 1
    let l:lastChar = strpart(l:thisPath, l:strLen)
    if l:lastChar != '' && expand(l:lastChar) == expand('/')
      let l:thisPath = strpart(l:thisPath, 0, l:strLen)
    endif
    let l:newPath =  a:bang . ' ' . fnameescape(l:thisPath . expand('/') . strftime('%Y%m%d') . '_' . a:2)
  endif
  if a:doMove == 1
    exec 'Move' . l:newPath
  else
    exec 'keepalt saveas' . l:newPath
  endif
endfunction
command! -nargs=* -bang -complete=file DateSave :call DateSaveFunc(<q-bang>, 0, <f-args>)
command! -nargs=* -bang -complete=file DateMove :call DateSaveFunc(<q-bang>, 1, <f-args>)

function! ViewTexCharList()
  vnew
  edit $VIMRUNTIME/syntax/tex.vim
  silent! vertical resize 40

  silent! set bufhidden=delete
  silent! setlocal noswapfile
  nnoremap <buffer>q :q<CR>
  " Go to the first line of the file
  :0
  " Search for (and therefore go to) the variable in which the list is stored
  /texMathList
  nohl
  " Make sure the list takes up most of the window
  silent! normal! zt
endfunction
command! -nargs=0 -buffer ViewTexCharList call ViewTexCharList()

"""""""""""""""""""""""""""""""""" Movement """""""""""""""""""""""""""""""""""
" Check out http://stackoverflow.com/questions/16082991/vim-switching-between-files-rapidly-using-vanilla-vim-no-plugins
" Number of lines to use for the command line
set cmdheight=2
" The minimum number of line to keep above and below the cursor.
set scrolloff=10
" Allow keys to move left or right to the prev/next line
set whichwrap=b,s,h,l,<,>,[,]

" Use the mouse if we have a gui
if has('gui')
  set mouse=a
" If we are on command line, ignore the mouse
else
  set mouse=
endif

" Move to the beginning and end of lines easier
"nnoremap H ^
"nnoremap L $

" Use sane movement along wrapped lines
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

" Make single quote jump to the character where the mark was placed at instead
" of just the line
nnoremap ' `
nnoremap ` '

" Only jumps around the current buffer.
function! JumpInFile(back, forw)
  let [n, i] = [bufnr('%'), 1]
  let p = [n] + getpos('.')[1:]
  sil! exe 'norm!1' . a:forw
  while 1
    let p1 = [bufnr('%')] + getpos('.')[1:]
    if n == p1[0] | break | endif
    if p == p1
      sil! exe 'norm!' . (i-1) . a:back
      break
    endif
    let [p, i] = [p1, i+1]
    sil! exe 'norm!1' . a:forw
  endwhile
endfunction
nnoremap <silent><leader><C-o> :call JumpInFile("\<C-i>", "\<C-o>")<CR>
nnoremap <silent><leader><C-i> :call JumpInFile("\<C-o>", "\<C-i>")<CR>

" Binds numpad home/end to move 1/2 page up/down.
" When I sit back to think I like moving around the page with only one hand,
" usually the right one. This lets me do that. Would use PgUp/PgDown, but Mintty
" or tmux captures those with my settings.
nnoremap <kEnd> <C-d>
nnoremap <kHome> <C-u>


" Get off my lawn (Turn off arrow keys, and give some friendly advice)
" Note: May wish to remove nmap for up/down because the commands slightly bleed
" over to insert mode for a time after the switch.
inoremap <Left> <C-o>:echom "Use h"<CR>
inoremap <Right> <C-o>:echom "Use l"<CR>
vnoremap <Left> <Esc>:echom "Use h"<CR>
vnoremap <Right> <Esc>:echom "Use l"<CR>
vnoremap <Up> <Esc>:echom "Use k"<CR>
vnoremap <Down> <Esc>:echom "Use j"<CR>
nnoremap <Left> :echom "Use h"<CR>
nnoremap <Right> :echom "Use l"<CR>
nnoremap <Up> :echom "Use k"<CR>
nnoremap <Down> :echom "Use j"<CR>

" Turn off up and down arrows completely in insert mode, as the mouse scroll
" is interpreted as scroll and gets past any other mapping and goes back to
" default behavior. Also preceding command with <Esc> isn't ideal.
inoremap <Up> <Nop>
inoremap <Down> <Nop>
nnoremap <Up> <Nop>
nnoremap <Down> <Nop>

" Allows one to switch buffers without having to save or undo changes first.
set hidden

" Make buffer tab navigation quicker
nnoremap ]b :bnext<CR>
nnoremap [b :bprev<CR>
nnoremap ]t :tabnext<CR>
nnoremap [t :tabprev<CR>
" switch to last used buffer
nnoremap tt :b#<CR>

" Go to next file in location list
nnoremap <leader>s] :lnext<CR>
nnoremap <leader>s[ :lprevious<CR>
" make window navigation easier.
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l

nnoremap <F5> :ls<CR>:buffer<SPACE>
if !empty($NO_VIM_PLUGINS)
  nnoremap <leader>b :ls<CR>:buffer<SPACE>
endif

if has('nvim')
  augroup FZFNvim
    autocmd!
    autocmd TermOpen */*fzf* tnoremap <buffer><c-k> <UP>
    autocmd TermOpen */*fzf* tnoremap <buffer><c-j> <DOWN>
  augroup END
endif

if has('nvim')
  if empty($TMUX)
    tnoremap <C-s> <C-\><C-n>
  endif

  tnoremap <A-j><A-k> <C-\><C-n>
  tnoremap <C-q> <C-\><C-n>
  tnoremap <ESC> <C-\><C-n>

  tnoremap <C-h> <C-\><C-n><C-w>h
  tnoremap <C-j> <C-\><C-n><C-w>j
  tnoremap <C-k> <C-\><C-n><C-w>k
  tnoremap <C-l> <C-\><C-n><C-w>l
endif

"""" Notes
":bro ol (AKA :browse oldfiles) lists previously opened files and allows you to open one
"<c-o> Returns you to locations before jumps. <c-i> (also tab) moves you forward

"""" If there is a local vim configuration file, run it
if filereadable(g:vimDirectoryPart . ".vimrc.local")
  exec "so " . g:vimDirectoryPart . ".vimrc.local"
endif
