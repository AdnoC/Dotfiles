" Vim preferneces file
" Sections:
"   -> Initial
"   -> Plugins
"   -> File Types
"   -> Meta
"   -> Looks
"   -> Formatting
"   -> Searching
"   -> Msc
"   -> Movement
"   -> Key List and other things
"
" Note: Mappings have a }{ symbol at the end of the line
"


""""""""""""""""""""""""""""""""""" Initial """""""""""""""""""""""""""""""""""
" This isn't Vi, it is Vi IMproved. So lets not cling to old Vi settings
if has('vim_starting')
  set nocompatible
endif
" Remap leader. Needs to be done before any mappings involving the leader.   }{
let mapleader=" "


""""""""""""""""""""""""""""""""""" Plugins """""""""""""""""""""""""""""""""""
filetype off
" Auto vundle install, taken from (before being slightly edited):
" http://erikzaadi.com/2012/03/19/auto-installing-vundle-from-your-vimrc/
" Setting up Vundle - the vim plugin bundler
    let iCanHazNeobundle=1
    let neobundle_readme=expand('~/.vim/bundle/neobundle.vim/README.md')
    if !filereadable(neobundle_readme)
        echo "Installing Neobundle.."
        echo ""
        silent !mkdir -p ~/.vim/bundle
        silent !git clone https://github.com/Shougo/neobundle.vim ~/.vim/bundle/neobundle.vim
        let iCanHazNeobundle=0
    endif
    if has('vim_starting')
      "required
      set runtimepath+=~/.vim/bundle/neobundle.vim/
    endif
    " Required:
    call neobundle#begin(expand('~/.vim/bundle/'))
    " Let NeoBundle manage NeoBundle
    " Required:
    NeoBundleFetch 'Shougo/neobundle.vim'
    "Add your bundles here
    let vimproc_updcmd = has('win64') ?
      \ 'tools\\update-dll-mingw 64' : 'tools\\update-dll-mingw 32'
execute "NeoBundle 'Shougo/vimproc.vim'," . string({
      \ 'build' : {
      \     'windows' : vimproc_updcmd,
      \     'cygwin' : 'make -f make_cygwin.mak',
      \     'mac' : 'make -f make_mac.mak',
      \     'unix' : 'make -f make_unix.mak',
      \    },
      \ })
    NeoBundle 'othree/html5.vim'
    NeoBundle 'kien/ctrlp.vim'
    " So that gitv can work
    NeoBundle 'tpope/vim-fugitive'
    NeoBundle 'gregsexton/gitv', {
      \ 'depends' : 'vim-fugitive' }
    NeoBundle 'edkolev/promptline.vim'
    NeoBundle 'scrooloose/syntastic'
    NeoBundle 'bling/vim-airline'
    NeoBundle 'bling/vim-bufferline'
    NeoBundle 'mhinz/vim-signify'
    NeoBundle 'airblade/vim-gitgutter'
    NeoBundle 'altercation/vim-colors-solarized'
    NeoBundle 'tpope/vim-surround'
    NeoBundle 'wikitopian/hardmode'
    NeoBundle 'scrooloose/nerdcommenter'
    NeoBundle 'scrooloose/nerdtree'
    NeoBundle 'kien/rainbow_parentheses.vim'
    " Ctags are a dependancy of tagbar
    if executable('ctags')
      NeoBundle 'majutsushi/tagbar'
      NeoBundle 'vim-php/phpctags', {
        \ 'depends' : 'tagbar',
        \ 'build' : {
          \ 'cygwin' : 'make -f Makefile',
          \ 'unix' : 'make -f Makefile',
          \ 'mac' : 'make -f Makefile'
        \ }}
      NeoBundle 'vim-php/tagbar-phpctags.vim', {
        \ 'depends' : 'phpctags',
        \ 'build' : {
          \ 'cygwin' : 'make -f Makefile',
          \ 'unix' : 'make -f Makefile',
          \ 'mac' : 'make -f Makefile'
        \ }}
    else
      echo 'Cannot find ctags. Not installing tagbar.'
    endif
    NeoBundle 'sjl/gundo.vim'
    NeoBundle 'nathanaelkane/vim-indent-guides'
    NeoBundle 'Lokaltog/vim-easymotion'
    NeoBundle 'edsono/vim-matchit'
    NeoBundle 'tpope/vim-abolish'
    NeoBundle 'tpope/vim-repeat'
    NeoBundle 'sheerun/vim-polyglot'
    NeoBundle 'Valloric/MatchTagAlways'
    NeoBundle 'tpope/vim-endwise'
    NeoBundle 'thinca/vim-ref'
    NeoBundle 'jiangmiao/auto-pairs'
    if executable('tmux')
      NeoBundle 'benmills/vimux'
      NeoBundle 'edkolev/tmuxline.vim'
    endif
    if executable('w3m')
      NeoBundle 'yuratomo/w3m.vim'
    endif
    call neobundle#end()
        "...All your other bundles...
    if iCanHazNeobundle == 0
      echo "Installing Plugins, please ignore key map error messages"
      echo ""
      NeoBundleCheck
    endif
" Setting up Neobundle - the vim plugin bundler end

" Brief help
" :PluginInstal
" :PluginList          - list configured plugins
" :PluginInstall(!)    - install (update) plugins
" :PluginSearch(!) foo - search (or refresh cache first) for foo
" :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins

filetype plugin indent on

"""" Syntastic:
" Turn it on by default, so far no filetypes where it needs to be off.
let g:syntastic_mode_map = { 'mode': 'active',
  \ 'active_filetypes': [],
  \ 'passive_filetypes': [] }
" Better :sign interface symbols
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '!'
" Aggregate errors from multiple checkers
let g:syntastic_aggregate_errors = 1
" Automatically open location window if there are errors
let g:syntastic_auto_loc_list=1
" Show current error in command window
let g:syntastic_echo_current_error = 1
" Populate loclist with errors
let g:syntastic_always_populate_loc_list = 1
" Enable on open file
let g:syntastic_check_on_open = 1
" Set location list window height
let g:syntastic_loc_list_height = 5
" Shortcuts to prev/next errors                                              }{
nnoremap <leader>s] :lnext<CR>
nnoremap <leader>s[ :lprevious<CR>

"""" Vim Airline:
" Show a list of files on the top of the screen
let g:airline#extensions#tabline#enabled = 1
" Set the theme to solarized
if !exists('g:airline_theme')
  let g:airline_theme = 'solarized'
endif
" Use fancy fonts
let g:airline_powerline_fonts = 1
" Also show list of files on bottom of screen
let g:airline#extension#bufferline#enabled=1
" Only show git stats that are non-zero
let g:airline#extensions#hunks#non_zero_only=1
" Tmuxline looks nice and should be used if we have tmux
let g:airline#extensions#tmuxline#enabled=1
" Clean up the status bar:
" Just show the list of files/buffers in section c
let g:airline_section_c = "%f%m %{bufname('#') != '' ? '('. expand('#:t') .')' : ''}"
" No need to show filetype in the status bar, the ctags section is enough
let g:airline_section_x='%{airline#util#prepend(airline#extensions#tagbar#currenttag(),0)}%'
" Also don't need to know the formatting. Just leave it empty
let g:airline_section_y=''

"""" Vim Gitgutter:
" Tell gitgutter not to set any keybinds by itself. They will all be rebound.
let g:gitgutter_map_keys = 0
" Move from to the next/prev change                                          }{
nmap <leader>g] <Plug>GitGutterNextHunk
nmap <leader>g[ <Plug>GitGutterPrevHunk
" Stage or revert the lines the cursor is on                                 }{
nmap <Leader>gs <Plug>GitGutterStageHunk
nmap <Leader>gr <Plug>GitGutterRevertHunk
" Preview the changes                                                        }{
nmap <Leader>gp <Plug>GitGutterPreviewHunk

let g:solarized_termcolors=256
let g:solarized_termtrans=1
let g:solarized_visibility='high'

"""" Rainbow Parentheses:                                                    }{
" Make rainbow parentheses an acual rainbow
let g:rbpt_colorpairs = [
  \ [ '13', '#6c71c4'],
  \ [ '5',  '#d33682'],
  \ [ '1',  '#dc322f'],
  \ [ '9',  '#cb4b16'],
  \ [ '3',  '#b58900'],
  \ [ '2',  '#859900'],
  \ [ '6',  '#2aa198'],
  \ [ '4',  '#268bd2'],
  \ ]
" Calls all the functions to load rainbow parens
function! LoadRainbow()
  RainbowParenthesesActivate
  RainbowParenthesesLoadRound
  RainbowParenthesesLoadSquare
  RainbowParenthesesLoadBraces
  RainbowParenthesesLoadChevrons
endfunction
map <F6> :call LoadRainbow()<CR>
" Wrapper function that only lets RainbowParens run if it works with the file
" type
function! MaybeRainbow()
  if &ft != "php"
    call LoadRainbow()
  endif
endfunction

"""" Tagbar:
" Bind a button to open the tagbar                                         }{
nnoremap <leader>tg :TagbarToggle<CR>
let g:tagbar_autoclose=1
let g:tagbar_autofocus=1

"""" NERD Tree:
" Bind a button to open NERD Tree                                            }{
nnoremap <leader>nt :NERDTreeToggle<CR>
let NERDTreeQuitOnOpen=1
let NERDTreeDirArrows=0
let NERDTreeShowHidden = 1

"""" Gundo:
" Bind a button to open Gundo                                                }{
nnoremap <leader>gu :GundoToggle<CR>

"""" Indent Guides:
" The default bind, just here so I remember
nnoremap <leader>ig :IndentGuidesToggle<CR>
let g:indent_guides_start_level=2
let g:indent_guides_guide_size=1


"""" Easy Motion:
"nmap <leader> <Plug>(easymotion-prefix)
let g:EasyMotion_do_mapping = 0 " Disable default mappings
" Make some easymotion binds                                                 }{
nmap <leader>l <Plug>(easymotion-lineforward)
nmap <leader>h <Plug>(easymotion-linebackward)
nmap <leader>j <Plug>(easymotion-j)
vmap <leader>j <Plug>(easymotion-j)
nmap <leader>k <Plug>(easymotion-k)
vmap <leader>k <Plug>(easymotion-k)
nmap <leader>s <Plug>(easymotion-s2)
vmap <leader>s <Plug>(easymotion-s2)
nmap <leader><ENTER> <Plug>(easymotion-sn)
let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

"""" NERD Commenter:
" Use custon NERD commenter mapping                                          }{
let g:NERDCreateDefaultMappings=0
nmap <leader>cv <Plug>NERDCommenterComment
vmap <leader>cv <Plug>NERDCommenterComment
nmap <leader>cx <Plug>NERDCommenterUncomment
vmap <leader>cx <Plug>NERDCommenterUncomment


" Fixes most gui problems (broken syntax coloring, status bar no color)      }{
function! FixGUI()
  syntax enable
  if expand("$SOL_FLAVOR") == 'light'
    set background="light"
  else
    set background="dark"
  endif
  colorscheme solarized
  call MaybeRainbow()
endfunction
map <F9> :call FixGUI()<CR>

"""" W3m:
" Bind w3m to an easy key and add http so it doesn't search.                 }{
nnoremap <leader>w3 :W3m http://
autocmd FileType w3m nnoremap <buffer>q :W3mClose<CR>
autocmd FileType w3m nnoremap <buffer>o :W3mAddressBar<CR>

"""" CtrlP:
" Ignore some folders and files for CtrlP indexing
let g:ctrlp_custom_ignore={
  \ 'dir':  '\.git$\|\.yardoc\|public$|log\|tmp$',
  \ 'file': '\.so$\|\.dat$|\.DS_Store$'
  \ }
let g:ctrlp_show_hidden = 1
" Navigate to specific buffers quickly                                       }{
map <C-s> :CtrlPBuffer<CR>
"""" Vimux:                                                                  }{
map <leader>vp :VimuxPromptCommand<CR>
map <leader>vr :VimuxRunLastCommand<CR>
map <leader>vo :VimuxInspectRunner<CR>
map <leader>vc :VimuxCloseRunner<CR>

"""" Gitv:
" Be Smart About Whether To Open The Browser In A Horizontal Or Vertical Tab
let g:Gitv_OpenHorizontal='auto'
" Mercilessly Purge All Fugitive Buffers In The Browser Tab
let g:Gitv_WipeAllOnClose=1
" Don't map the ctrl key. otherwise I'd constantly open new windows
let g:Gitv_DoNotMapCtrlKey = 1


"""""""""""""""""""""""""""""""""" File Types """""""""""""""""""""""""""""""""
" How to set filetypes: (an example of setting one as ruby)
" au BufRead,BufNewFile *.rpdf       set ft=ruby
"autocmd BufReadPre,BufNewFile *.inc set filetype=php
"autocmd BufReadPre,BufNewFile *.module set filetype=php


"""""""""""""""""""""""""""""""""""" Meta """""""""""""""""""""""""""""""""""""
" Remap ';' to ':' for easier commands                                       }{
nnoremap ; :
" Use Control-a to move to normal mode                                       }{
inoremap jk <Esc>
" Allow the use of a familiar key combination to exit visual mode            }{
vnoremap jk <Esc>
" Toggle paste mode.
set pastetoggle=<F11>
" Makes the switch to paste mode immediately shown                           }{
map <F11> :set invpaste paste?<CR>
" Change vim pwd to dir of file to easily open other files in dir            }{
nnoremap <leader>cd :cd %:p:h<CR>
" Open the current directory in a new tab                                    }{
nnoremap <leader>te :tabedit <c-r>=expand("%:p:h")<CR>/

" We aren't going to have any vim variables at the beginning or end of files
set modelines=0
" Turn on wild menu (Allow tab use with the command line)
set wildmenu
" Settings for wildmenu (:h wildmenu)
set wildmode=list:longest,list:full
" Get rid of the help key
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>

" Use generic omnicompletion if something more specific isn't already set
if has("autocmd") && exists("+omnifunc")
    au Filetype *
        \ if &omnifunc == "" | setl omnifunc=syntaxcomplete#Complete | endif
endif

" auto-save on focus loss
au FocusLost * :wa
" return to last edit position when opening files (you want this!)
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
" Open .vimrc                                                                }{
nnoremap <leader>ev <c-w><c-v><c-l>:e $MYVIMRC<CR>
"""" Meta files
" Create backup, swap, and undo  folders if they do not exist
" Centralize backups, swapfiles and undo history
 if ! isdirectory(expand('$HOME/.vim/backups'))
  call mkdir(expand('$HOME/.vim/backups'))
endif
 if ! isdirectory(expand('$HOME/.vim/swaps'))
  call mkdir(expand('$HOME/.vim/swaps'))
endif
 if has('persistent_undo')
  " Store undo data in a file for persistence between sessions
  set undofile
  if ! isdirectory(expand('$HOME/.vim/undo'))
    call mkdir(expand('$HOME/.vim/undo'))
  endif
  set undodir=~/.vim/undo
endif
set backupdir=~/.vim/backups
set directory=~/.vim/swaps


"""""""""""""""""""""""""""""""""""" Looks """"""""""""""""""""""""""""""""""""
"""" Color Scheme
" If using vimdiff, use a colorscheme that is actually readable.
if &diff
  colorscheme blue
endif

" Refresh busted syntax highlighting (this happens too often)                }{
map <F12> :syntax sync fromstart<cr>

" Don't turn syntax or highlight searching on unless there are enough colors
" to make them look good
if (&t_Co > 2 || has("gui_running") || $TERM =~ '-256color') && has("syntax")
    " Use 256 colors
    set t_Co=256
    " Start vim with solarized theme of the correct flavor
    syntax enable
    if expand("$SOL_FLAVOR") == 'light'
      set background="light"
    else
      set background="dark"
    endif
    colorscheme solarized
    " If we open a new buffer, and after any final filetype changes
    autocmd FileType,BufRead * call MaybeRainbow()
    " Highlight search matches
    set hlsearch
endif

" Use relative line numbers if we can
if exists("&relativenumber")
  set relativenumber
  "au BufReadPost * set relativenumber
else
  " If there is no relative numbering on the system, use static numbers
  set number
endif

" Show on status bar line & column number, relative % in file
set ruler
" Don't display incomplete commands
set noshowcmd
" Shut the fuck up (Screen flashes instead of making a beep)
set visualbell
" Highlight current line (Horizontal underline)
set cursorline
" No need to show the mode, as airline will show it for us
set noshowmode
" Always show the status line (I use airline, so I want to see it)
set laststatus=2
" Wrap lines of text that are too long around to the next line
set wrap
" Show column at x chars so that there is no lines to long
if exists('+colorcolumn')
  set colorcolumn=80
endif
" Show the number of changes made when doing substitutions
set report=0
" When closing a parenthesis or bracket (etc) briefly move cursor to its match
set showmatch
" How long in 1/10s of a second to show the match
set matchtime=5
" Use utf-8 encoding. Needs to be set before listchars on some systems.
set encoding=utf-8
" Show hidden chars
set list
" Set hidden chars to show (Show tabs and trailing spaces)
set listchars=tab:›\ ,trail:·,eol:¬,nbsp:_
" Turn off lazy redraw
set nolazyredraw
" We are using a fairly fast terminal connection most times
set ttyfast
" When switching buffers, preserve window view.(Vim tip 1375)
if v:version >= 700
  au BufLeave * if !&diff | let b:winview = winsaveview() | endif
  au BufEnter * if exists('b:winview') && !&diff | call winrestview(b:winview) | unlet! b:winview | endif
endif


""""""""""""""""""""""""""""""""" Formatting """"""""""""""""""""""""""""""""""
" Strips excess whitespace from file                                         }{
nnoremap <leader>w :%s/\s\+$//<CR>:let @/=''<CR>
" Converts existing tabs to spaces                                           }{
nnoremap <leader>t :retab<CR>
" Use smart indenting when starting a new line
set smartindent
" Number of spaces to use for auto-indent ('>>' or '<<)
set shiftwidth=2
" Number of spaces a tab in a file counts for
" shiftwidth spaces.
set tabstop=2
" Use an appropriate number of spaces instead of tabs when typing <Tab>
set expandtab
" At start of line, <Tab> inserts shiftwidth spaces, <Bs> deletes
set smarttab
" The maximum width of a line of text. Lines that go longer will be broken
" after a whitespace
set textwidth=100
" Sets how vim formats text (see :h fo-table)
set formatoptions=qrno
" Set line ending preferences (CR LR stuff)
set ffs=unix,dos,mac
" Creates a gutter on the left side ofthe screen showing fold info
" By default do not show the gutter
autocmd FileType * set foldcolumn=0
" Show the gutter for only specified filetypes
autocmd FileType javascript set foldcolumn=6
" Auto include folds based on syntax
set foldmethod=syntax
" Reselect visual block after indent/outdent                                }{
vnoremap < <gv
vnoremap > >gv
" Re-hardwrap paragraph                                                      }{
nnoremap <leader>q gqip


"""""""""""""""""""""""""""""""""" Searching """"""""""""""""""""""""""""""""""
" Clears  the search by pressing <leader> COMMA                              }{
nnoremap <silent><leader>, :noh<CR>
set ignorecase             " ignore case when searching
set smartcase
" Use sane regexes                                                           }{
nnoremap / /\v
vnoremap / /\v
nnoremap ? ?\v
vnoremap ? ?\v
set incsearch   " Search incrementally


"""""""""""""""""""""""""""""""""""" Msc. """""""""""""""""""""""""""""""""""""
" Remove the Windows ^M - when the encodings gets messed up                  }{
noremap <Leader>m mmHmt:%s/<C-V><CR>//ge<CR>'tzt'm
" Allow backspacing over everything in insert mode (:h bs)
set backspace=indent,eol,start
" Helps if you have to use another editor on the same file
au FileChangedShell * echoerr "File has been changed outside of Vim."
" Specify how keyword completion works
set complete=.,t
set completeopt=longest,menu
" Open new split windows to right and bottom, which feels more natural
set splitbelow
set splitright
" Make Y behave like other capitals                                          }{
nnoremap Y y$
" Replace a word with yanked text                                            }{
nnoremap <leader>rp viw"0p
"""" Help
" Press Enter to follow a help tag
au filetype help nnoremap <buffer><CR> <c-]>
" Press Backspace to go back to the location of the previous tag
au filetype help nnoremap <buffer><BS> <c-T>
" Press q to exit the help
au filetype help nnoremap <buffer>q :q<CR>
au filetype help set nonumber
" Displays a list of maps that include the leader
function! ListLeaders()
  silent! redir @b
  silent! nmap <LEADER>
  silent! redir END
  silent! new
  silent! set buftype=nofile
  silent! set bufhidden=hide
  silent! setlocal noswapfile
  silent! put! b
  silent! g/^s*$/d
  silent! %s/^.*,//
  silent! normal ggVg
  silent! sort
  silent! let lines = getline(1,"$")
  silent! normal <esc>
endfunction
command! ListLeaders :call ListLeaders()


"""""""""""""""""""""""""""""""""" Movement """""""""""""""""""""""""""""""""""
" Number of lines to use for the command line
set cmdheight=2
" The minimum number of line to keep above and below the cursor.
set scrolloff=10
" Allow keys to move left or right to the prev/next line
set whichwrap=b,s,h,l,<,>,[,]

" Move to the beginning and end of lines easier                              }{
nnoremap H ^
nnoremap L $

" Use sane movement along wrapped lines                                      }{
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

" Only jumps around the current buffer.                                      }{
function! JumpInFile(back, forw)
  let [n, i] = [bufnr('%'), 1]
  let p = [n] + getpos('.')[1:]
  sil! exe 'norm!1' . a:forw
  while 1
    let p1 = [bufnr('%')] + getpos('.')[1:]
    if n == p1[0] | break | endif
    if p == p1
      sil! exe 'norm!' . (i-1) . a:back
      break
    endif
    let [p, i] = [p1, i+1]
    sil! exe 'norm!1' . a:forw
  endwhile
endfunction
nnoremap <silent><leader><C-o> :call JumpInFile("\<C-i>", "\<C-o>")<CR>
nnoremap <silent><leader><C-i> :call JumpInFile("\<C-o>", "\<C-i>")<CR>

" Binds numpad home/end to move 1/2 page up/down.
" When I sit back to think I like moving around the page with only one hand,
" usually the right one. This lets me do that. Would use PgUp/PgDown, but Mintty
" or tmux captures those with my settings.                                   }{
nnoremap <kEnd> <C-d>
nnoremap <kHome> <C-u>


" Get off my lawn (Turn off arrow keys, and give some friendly advice)       }{
" Note: May wish to remove nmap for up/down because the commands slightly bleed
" over to insert mode for a time after the switch.
inoremap <Left> <C-o>:echom "Use h"<CR>
inoremap <Right> <C-o>:echom "Use l"<CR>
vnoremap <Left> <Esc>:echom "Use h"<CR>
vnoremap <Right> <Esc>:echom "Use l"<CR>
vnoremap <Up> <Esc>:echom "Use k"<CR>
vnoremap <Down> <Esc>:echom "Use j"<CR>
nnoremap <Left> :echom "Use h"<CR>
nnoremap <Right> :echom "Use l"<CR>
nnoremap <Up> :echom "Use k"<CR>
nnoremap <Down> :echom "Use j"<CR>

" Turn off up and down arrows completely in insert mode, as the mouse scroll
" is interpreted as scroll and gets past any other mapping and goes back to
" default behavior. Also preceding command with <Esc> isn't ideal.           }{
inoremap <Up> <nop>
inoremap <Down> <nop>
nnoremap <Up> <nop>
nnoremap <Down> <nop>

" Allows one to switch buffers without having to save or undo changes first.
set hidden

" Make tab navigation quicker                                                }{
nnoremap <Leader>] :bnext<CR>
nnoremap <leader>[ :bprev<CR>
" switch to last used tab                                                    }{
nnoremap tt :b#<CR>
" make window navigation easier.                                             }{
map <c-h> <c-w>h
map <c-j> <c-w>j
map <c-k> <c-w>k
map <c-l> <c-w>l


"""""""""""""""""""""""""""""""""" Key List """""""""""""""""""""""""""""""""""
" List of mapped keys:
" <SPACE>
" <leader>s]
" <leader>s[
" <leader>g[
" <leader>g]
" <leader>gs
" <leader>gr
" <leader>gp
" <F6>
" <F9>
" <F1>
" <F12>
" <F11>
" <leader>vo
" <leader>vp
" <leader>vr
" <leader>vc
" jk
" <leader>cd
" <leader>te
" <leader>ev
" <leader>w
" <leader>t
" <leader>q
" <leader>m
" <leader>,
" <leader>[
" <leader>]
" tt
" <c-h>
" <c-j>
" <c-k>
" <c-l>
" <leader>rp
" <leaer>gu
" <leader>tg
" <leader>nt
" <leader>l
" <leader>k
" <leader>j
" <leader>h
" <leader>s
" <leader><ENTER>
" Y (kinda)
" H
" L
" <M-o>
" <M-i>
" <kHome>
" <kEnd>
" <C-s>

"""" Notes
":bro ol (AKA :browse oldfiles) lists previously opened files and allows you to open one
"<c-o> Returns you to locations before jumps. <c-i> (also tab) moves you forward

"""" If there is a local vim configuration file, run it
if filereadable(expand("~/.vimrc.local"))
  so ~/.vimrc.local
endif
