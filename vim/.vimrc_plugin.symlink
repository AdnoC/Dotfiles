" Vim plugin configuration

" A simpler plugin setup is available for environments where some things are not
" available.
" It disables some plugins that have a usage cost.
" To enable it, set the environmental variable SIMPLE_VIM_PLUGINS.

" If you want to setup a plugin config for a minimal environment (such as a phone),
" set the environmental variable STANDALONE_VIM_PLUGINS.
" It will make sure that the only plugins enabled are those that depend wholly on
" vimL.

" Set that we decided to use plugins
let g:USE_PLUGINS=1
let $MYVIMRCPLUGIN=expand('<sfile>')


" Check whether there is an executable with a given name
" If we are using standalone plugins we automatically return false
function! s:has_exec(prog_name) abort
  return empty($STANDALONE_VIM_PLUGINS) && executable(a:prog_name)
endfunction


" Plugin Alternatives {
" Used in checking which of several alternatives is used
let s:syntax_syntastic = 'syntastic'
let s:syntax_neomake = 'neomake'
let s:autocomplete_ycm = 'ycm'
let s:autocomplete_neocomplete = 'neocomplete'
let s:autocomplete_deoplete = 'deoplete'
let s:autocomplete_supertab = 'supertab'
" }

"""" Plugin Manager: (Vim-Plug)
let VimPlugInitialized=1
" Download plugin manager {
if empty(glob(expand(g:vimDirectory . '/autoload/plug.vim')))
  let VimPlugInitialized=0
  " I know that all these could be replaced with just the git one. But I don't want to delete them
  if executable("curl")
    silent exec '!curl -fLo ' . shellescape(expand(g:vimDirectory."/autoload/plug.vim")) .
        \ ' --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  elseif executable("wget")
    " wget can't make folders on its own, so we need to make .vim/autoload for it
    if executable("mkdir")
      silent exec '!mkdir -p ' . shellescape(expand(g:vimDirectory."/autoload/"))
    endif
    silent exec '!wget -q -O ' . shellescape(expand(g:vimDirectory."/autoload/plug.vim")) .
        \ '  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  " If we are on Windows we can use Powershell to download it
  elseif executable("powershell")
    silent exec '!if not exist ' . shellescape(expand(g:vimDirectory."/autoload")) . ' mkdir ' .
      \ shellescape(expand(g:vimDirectory."/autoload/"))
    silent exec '!powershell "(new-object System.Net.WebClient).DownloadFile(''https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'',''' .
      \ shellescape(expand(g:vimDirectory."/autoload/plug.vim")) . ''')"'

  " If all else fails we can just use git.
  elseif executable("git")
    silent exec '!git clone -q --depth=1 git@github.com:junegunn/vim-plug.git ' . shellescape(expand(g:vimDirectory."/temp"))
    if has('gui_win32')
      let s:mv="move "
      let s:rm="del "
    else
      let s:mv="mv "
      let s:rm="rm -rf "
    endif
    silent exec '!' . s:mv . shellescape(expand(g:vimDirectory."/temp/plug.vim")) .
      \ ' ' . shellescape(expand(g:vimDirectory."/autoload/plug.vim"))
    silent exec '!' . s:rm . shellescape(expand(g:vimDirectory."/temp/"))
  else
    echo "Couldn't find a way to download Vim-Plug. Not sure how you were planning" .
      \ " installing plugins without Git."
  endif

  if has('nvim')
    " Install python client
    if s:has_exec('pip')
      silent exec '!pip install neovim'
    endif
    if s:has_exec('pip3')
      silent exec '!pip3 install neovim'
    endif
  endif
  function! InstallMyPlugs() abort
    PlugInstall
    if has('nvim')
      UpdateRemotePlugins
    endif
  endfunction
  autocmd VimEnter * call InstallMyPlugs()
endif
" }

" Plugin Declarations: {
call plug#begin(g:vimDirectoryPart . 'bundle')

"Add your plugins here
" Games: {
Plug 'vim-scripts/TeTrIs.vim'
Plug 'johngrib/vim-game-code-break'
" }
" Git: {
if s:has_exec('git')
  " Commands for using git nicely in Vim
  " NOTE: fugitive makes vim very laggy sometimes
  Plug 'tpope/vim-fugitive'
  " Show git changes in gutter
  Plug 'airblade/vim-gitgutter'
endif
" }
""" Auto Formatting:
Plug 'jiangmiao/auto-pairs'
" Syntax: {
" FileType Specific: (syntax files) {
" General language pack
Plug 'sheerun/vim-polyglot'
Plug 'Konfekt/FastFold'
" Go: {
function! InstallGoBins(info) abort
  if a:info.status == 'installed'
    GoInstallBinaries
  elseif a:info.status == 'updated'
    GoUpdateBinaries
  endif
endfunction
if s:has_exec('go') && empty($SIMPLE_VIM_PLUGINS)
  Plug 'fatih/vim-go', { 'do': function('InstallGoBins')}
endif
" }

Plug 'rust-lang/rust.vim'
" Some more concealchars for tex
Plug 'KeitaNakamura/tex-conceal.vim'
if s:has_exec('pandoc') && empty($SIMPLE_VIM_PLUGINS)
  Plug 'vim-pandoc/vim-pandoc'
endif
Plug 'vim-pandoc/vim-pandoc-syntax'
if s:has_exec('python') && empty($SIMPLE_VIM_PLUGINS)
  Plug 'davidhalter/jedi-vim'
endif
Plug 'elzr/vim-json'
Plug 'groenewege/vim-less'
Plug 'vim-scripts/csv.vim', {'for': 'csv'}
Plug '2072/php-indenting-for-vim'
" Adds syntax highlighting for some keywords in React. vim-polyglot already provides JSX syntax.
Plug 'othree/javascript-libraries-syntax.vim', { 'for': 'javascript' }

" Helpers for creating comments
Plug 'AdnoC/jcommenter.vim', { 'for': 'java'}
Plug 'heavenshell/vim-jsdoc', { 'for': 'javascript'}


" Add docs for Java on 'J' keybind
Plug 'davetron5000/javax-xml-javadoc-vim', { 'for': 'java'}
Plug 'davetron5000/javax-javadoc-vim', { 'for': 'java'}
Plug 'davetron5000/java-javadoc-vim', { 'for': 'java'}
" }
if !&diff
  if (has('nvim') || v:version >= 8)
    let g:syntax_plugin = s:syntax_neomake
    Plug 'neomake/neomake'
  else
    let g:syntax_plugin = s:syntax_syntastic
    Plug 'scrooloose/syntastic'
  endif
else
  let g:syntax_plugin = ''
endif
" Set indent options based on what is used in the file
" Plug 'tpope/vim-sleuth'
" Auto-close some structures (i.e. adds 'endfunction' after
" you type 'function!' in VimL)
Plug 'tpope/vim-endwise'
Plug 'Yggdroot/indentLine', { 'on': 'IndentLinesToggle'}

if empty($SIMPLE_VIM_PLUGINS)
  Plug 'Shougo/neosnippet.vim'| Plug 'Shougo/neosnippet-snippets'
endif

" Autocomplete: {
" YouCompleteMe only works on Linux/Mac and if vim is version > 7.3.584
" Use supertab if YCM won't work
if !empty($STANDALONE_VIM_PLUGINS)
  let g:autocomplete_plugin = s:autocomplete_supertab
  Plug 'ervandew/supertab'
elseif (has('lua') || has('nvim'))
  if has('nvim')
    let g:autocomplete_plugin = s:autocomplete_deoplete
    Plug 'Shougo/deoplete.nvim'
  else
    let g:autocomplete_plugin = s:autocomplete_neocomplete
    Plug 'Shougo/neocomplete.vim'
  endif

  if s:has_exec('clang')
    " NOTE: deoplete-clang needs to point to clang's dynamic library, not just
    " where it can find the library
    " if (g:autocomplete_plugin == s:autocomplete_deoplete &&
    "       \ !empty($CLANG_INCLUDE_PATH) && !isdirectory($LIBCLANG_PATH))
      " Plug 'zchee/deoplete-clang'
    if g:autocomplete_plugin == s:autocomplete_deoplete
      Plug'tweekmonster/deoplete-clang2'

    elseif !empty($LIBCLANG_PATH)
      Plug 'Rip-Rip/clang_complete'
    endif
  elseif VimPlugInitialized == 0
    echo 'Cannot find clang, not installing clang completion'
  endif

  if s:has_exec('ternjs')
    if g:autocomplete_plugin == s:autocomplete_deoplete
      Plug 'carlitux/deoplete-ternjs', { 'for': 'javascript'}
    else
      Plug 'ternjs/tern_for_vim'
    endif
  elseif VimPlugInitialized == 0
    echo 'Cannot find tern, not installing javascript completion'
  endif

  if s:has_exec('flow')
    if g:autocomplete_plugin == s:autocomplete_deoplete
      Plug 'steelsojka/deoplete-flow', { 'for': 'javascript'}
    endif
  endif

  if s:has_exec('gocode')
    Plug 'zchee/deoplete-go', { 'do': 'make', 'for': 'go'}
  elseif VimPlugInitialized == 0
    echo 'Cannot find gocode, not installing go completion'
  endif

  if s:has_exec('python')
    Plug 'zchee/deoplete-jedi', { 'for': 'python'}
  endif

  " Vim autocomplete. Uncomment when you have something for it.
  " Plug 'Shougo/neco-vim'

  " File completion
  Plug 'Shougo/neoinclude.vim'

  " Syntx-based autocomplete TODO: Figure out if this is useful
  Plug 'Shougo/neco-syntax'

else
  let g:autocomplete_plugin = s:autocomplete_ycm
  " If we have a new enough version of cmake, use upsteam
  let g:ycmInstallCommand = "/install.py --clang-completer --tern-completer --go-completer"
  Plug 'Valloric/YouCompleteMe', { 'do': g:ycmInstallCommand}
        \ | Plug 'rdnetto/YCM-Generator', { 'branch': 'stable'}
endif
" Show function signature for auto-completed functions
Plug 'Shougo/echodoc.vim'

if empty($SIMPLE_VIM_PLUGINS)
  if s:has_exec('racer')
    Plug 'racer-rust/vim-racer'
  elseif (VimPlugInitialized == 0 && s:has_exec('cargo'))
    silent exec '!cargo install racer'
  endif
endif
" }

" }
" Tools: {
" Sources a .lvimrc file to allow for per-project configuration
Plug 'embear/vim-localvimrc'
" Shows all 256 x-term colors in a nice table
Plug 'guns/xterm-color-table.vim'
" Fixes <C-A> and <C-X> to correctly increment/decrement dates
Plug 'tpope/vim-speeddating'
" Makes ga show additional info about a character
Plug 'tpope/vim-characterize'
" Shows (vim) syntax info as well as color of stuff.
Plug 'vim-scripts/SyntaxAttr.vim'
" Commands for using unix commands nicely in Vim
Plug 'tpope/vim-eunuch'
" Close buffers without closing windows
Plug 'qpkorr/vim-bufkill'
Plug 'tomtom/tcomment_vim'
" File Explorer Plugin
Plug 'jeetsukumaran/vim-filebeagle'
Plug 'mbbill/undotree'
" Fuzzy search for files, buffers, and recent files
if empty($STANDALONE_VIM_PLUGINS) && empty($SIMPLE_VIM_PLUGINS)
  Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
  Plug 'junegunn/fzf.vim'
else
  Plug 'ctrlpvim/ctrlp.vim'
endif
" Align text
Plug 'tommcdo/vim-lion'

Plug 'kana/vim-operator-user'
Plug 'kana/vim-textobj-user'
if s:has_exec('ctags')
  " Auto-generate tag files
  Plug 'ludovicchabant/vim-gutentags'
endif
if s:has_exec('cscope')
  Plug 'chazy/cscope_maps'
endif
" }
" Text Objects: {
" Allows for things like 'cs2a([' to change ((*)) to [(*)]
Plug 'osyo-manga/vim-textobj-multiblock'
" Allows for text objects to be between any specified char
Plug 'thinca/vim-textobj-between'
" Allows for the use of 'b' as a text objext of any [('"<
Plug 'rhysd/vim-textobj-anyblock'
" Allows text objects to only exist on one side of the carot
Plug 'tommcdo/vim-ninja-feet'
Plug 'coderifous/textobj-word-column.vim'
Plug 'kana/vim-textobj-indent'
Plug 'kana/vim-textobj-fold'
Plug 'glts/vim-textobj-comment'
" }
" Looks: {
" Colorschemes
" A good solarized replacement. Has a grey background unless bash colors are overritten.
Plug 'romainl/flattened'
" A light colorscheme. Not sure about it.
Plug 'NLKNguyen/papercolor-theme'
Plug 'altercation/vim-colors-solarized'
Plug 'lifepillar/vim-solarized8'
" Makes the status bar & buffer bar look nice and display useful info
if empty($SIMPLE_VIM_PLUGINS)
  Plug 'bling/vim-airline'
  Plug 'vim-airline/vim-airline-themes'
else
  Plug 'bling/vim-bufferline'
endif
" Dims paragraphs besides the one you are working on
Plug 'junegunn/limelight.vim'
" Removes distractions
Plug 'junegunn/goyo.vim'
" Plug 'luochen1990/rainbow'
" }
" Movement: {
Plug 'Lokaltog/vim-easymotion'
" Plug 'wikitopian/hardmode'
Plug 'rhysd/vim-operator-surround'
" Lets you replace text with something from a register (like pasting from register)
Plug 'kana/vim-operator-replace'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-repeat'
" matchit breaks [] jumping. Only use it when 100% useful
Plug 'k-takata/matchit.vim'
" }


" Tagbar: {
" Ctags are a dependancy of tagbar
if s:has_exec('ctags')
  Plug 'majutsushi/tagbar'
  if s:has_exec('php') && !has('win32')
    " Plug 'vim-php/phpctags'
    Plug 'vim-php/tagbar-phpctags.vim', { 'do': 'make'}
  endif
else
  if VimPlugInitialized == 0
    echo 'Cannot find ctags. Not installing tagbar.'
  endif
endif
" }

" Tmux: {
if s:has_exec('tmux')
  " Lets you use <C-hjkl> to move between both tmux and vim panes.
  Plug 'christoomey/vim-tmux-navigator'
  Plug 'benmills/vimux'
  Plug 'edkolev/tmuxline.vim', { 'on': ['Tmuxline', 'TmuxlineSnapshot'] }
else
  if VimPlugInitialized == 0
    echo 'Cannot find tmux. Not installing vimux or tmuxline'
  endif
endif
" }
" W3M: {
if s:has_exec('w3m')
  Plug 'yuratomo/w3m.vim'
elseif VimPlugInitialized == 0
  echo 'Cannot find W3m. Not installing w3m.vim'
endif
" }

call plug#end()
" }

    "...All your other bundles...
"if VimPlugInitialized == 0
  "echo "Installing Plugins, please ignore key map error messages"
  "echo ""
"endif

" Vimballs: {
" Installs all vimballs in the vimball directory
function! InstallVimballs() abort
  " For each file in the vimball diretcory...
  for f in split(glob(expand(g:vimDirectory . '/vimball/') . "*"))
    " Open the file in a new buffer
    exec 'new' f
    " Source the buffer
    source %
    " Then close the buffer
    bd
  endfor
endfunction
" }

" If we are in a new installation and therefore are installing plugins...
if VimPlugInitialized == 0
  echo "Intalling Vimballs"
  " Intall vimballs (UseVimball needs to be called after startup, therefore au)
  autocmd VimEnter * call InstallVimballs()
endif

" Plugin Settings: {

" Neomake: {
if g:syntax_plugin == s:syntax_neomake

  nnoremap <leader><ENTER> :Neomake<CR>
  " autocmd! BufWritePost * Neomake

  " Use gcc by default
  let g:neomake_cpp_enabled_makers = ['gcc']
  " Use different gcc args
  try
    let g:neomake_cpp_gcc_maker = neomake#makers#ft#cpp#gcc()
    let g:neomake_cpp_gcc_maker.args = g:neomake_cpp_gcc_maker.args
          \ + ['-std=c++14', '-Wall', '-Werror', '-Wextra', '-pedantic']
    let g:neomake_cpp_clang_maker = neomake#makers#ft#cpp#clang()
    let g:neomake_cpp_clang_maker.args = g:neomake_cpp_clang_maker.args
          \ + ['-std=c++14', '-Wall', '-Werror', '-Wextra', '-pedantic']
  catch
    echom "Couldn't set cpp maker options"
  endtry
  " Open location list when errors occur
  " Preserve cursor position
  let g:neomake_open_list = 2
  " Highlight lines with errors
  let g:neomake_highlight_lines=1

  augroup NeomakeErrorSigns
    au!
    autocmd ColorScheme *
          \ hi NeomakeErrorSign ctermfg=124
  augroup END
endif
" }

" Syntastic: {
" Turn it on by default, so far no filetypes where it needs to be off.
" let g:syntastic_mode_map = { 'mode': 'active',
"   \ 'active_filetypes': [],
"   \ 'passive_filetypes': ['java'] }
" Bind a button to check syntax when in passive mode
if g:syntax_plugin == s:syntax_syntastic
  autocmd FileType java nnoremap <leader>cc :SyntasticCheck<CR>
endif
" Better :sign interface symbols
let g:syntastic_error_symbol = 'âœ—'
let g:syntastic_warning_symbol = '!'
" Aggregate errors from multiple checkers
let g:syntastic_aggregate_errors = 1
" Automatically open location window if there are errors
let g:syntastic_auto_loc_list=1
" Show current error in command window
let g:syntastic_echo_current_error = 1
" Populate loclist with errors
let g:syntastic_always_populate_loc_list = 1
" Enable on open file
let g:syntastic_check_on_open = 1
" Set location list window height
let g:syntastic_loc_list_height = 5
" Check header files
let g:syntastic_cpp_check_header = 1
" Tell syntastic where SDL is located so it stops complaining
let g:syntastic_cpp_include_dirs = ['/usr/local/include/SDL2']
" Use modern C++ compile options
let g:syntastic_cpp_compiler_options = ' -std=c++14'
" Shortcuts to prev/next errors
let g:syntastic_java_javac_config_file_enabled = 1
let g:syntastic_javascript_checkers = ['eslint']
let g:syntastic_javascript_jsxhint_exec = 'jsx-jshint-wrapper'
" }

" NeoSnippet: {
if empty($SIMPLE_VIM_PLUGINS)
  imap <expr><TAB>
   \ pumvisible() ? "\<C-n>" :
   \ neosnippet#expandable_or_jumpable() ?
   \    "\<Plug>(neosnippet_expand_or_jump)" : "<TAB>"

  smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
  imap <C-k>     <Plug>(neosnippet_expand_or_jump)
  smap <C-k>     <Plug>(neosnippet_expand_or_jump)
  xmap <C-k>     <Plug>(neosnippet_expand_target)
endif
" }

" General Completion: {
function! s:completion_prev() abort
  return pumvisible() ? "\<C-p>" : "\<S-TAB>"
endfunction
imap <silent><S-TAB> <C-r>=<SID>completion_prev()<CR>
" }

" Deoplete: {
"" Run deoplete.nvim automatically
let g:deoplete#enable_at_startup = 1
let g:deoplete#enable_smart_case = 1
let g:deoplete#auto_complete_start_length=1
let g:deoplete#max_menu_width = 500
let g:deoplete#max_abbr_width = 500
let g:deoplete#sources = {}
let g:deoplete#ignore_sources = {}
" let g:deoplete#ignore_sources.cpp = ['buffer', 'syntax']
" let g:deoplete#ignore_sources.rust = ["buffer", "member", "tag", "file", "omni", "dictionary", "around"]
" let g:deoplete#ignore_sources.javascript = ["buffer", "member", "tag", "file", "omni", "dictionary", "around", "flow", "syntax"]
" let g:deoplete#ignore_sources.javascript = ["flow", "omni", "ternjs"]
let g:deoplete#ignore_sources.javascript = ["omni", "flow"]
let g:deoplete#ignore_sources.go = ["buffer", "syntax"]
" }

" Neocomplete: {
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#auto_complete_start_length=1
let g:neocomplete#enable_smart_case = 1
" }

" DeopleteGo: {
if g:autocomplete_plugin == s:autocomplete_deoplete
   augroup DeoGoMore
     autocmd!
     autocmd FileType go call deoplete#custom#set('go', 'rank', 9999)
   augroup END
 endif
let g:deoplete#sources#go#align_class = 1
if has('win32')
  let g:deoplete#sources#go#gocode_binary = expand($GOPATH.'/bin/gocode.exe')
endif
" }

" DeopleteClang: {
" let g:deoplete#sources#clang#libclang_path = $LIBCLANG_PATH
" let g:deoplete#sources#clang#clang_header = $CLANG_INCLUDE_PATH
" }

" ClangComplete: {
let s:clang_library_path = $LIBCLANG_PATH
if ((!has('nvim') || !empty($CLANG_INCLUDE_PATH)) && !isdirectory(s:clang_library_path))
  let s:clang_library_path = fnamemodify(s:clang_library_path, ':h')
endif
let g:clang_library_path = s:clang_library_path
let g:clang2_placeholder_next = '<c-k>'
let g:clang2_placeholder_prev = '<c-j>'
" }

" VimRacer: {
let g:racer_experimental_completer = 1
if s:has_exec('racer') && empty($SIMPLE_VIM_PLUGINS)
  augroup RacerBinds
    autocmd!
    autocmd FileType rust nmap gd <Plug>(rust-def)
    autocmd FileType rust nmap gs <Plug>(rust-def-split)
    autocmd FileType rust nmap gx <Plug>(rust-def-vertical)
    autocmd FileType rust nmap <leader>gd <Plug>(rust-doc)
    autocmd FileType rust nmap K <Plug>(rust-doc)
  augroup END

  if g:autocomplete_plugin == s:autocomplete_deoplete
     augroup RacerMore
       autocmd!
       autocmd FileType rust call deoplete#custom#set('racer', 'rank', 9999)
     augroup END
  endif
endif
" }

" DeopleteTernjs: {
let g:deoplete#sources#ternjs#tern_bin = 'ternjs'
let g:deoplete#sources#ternjs#filetypes = [
                \ 'jsx',
                \ 'javascript.jsx',
                \ 'vue',
                \ ]
let g:deoplete#sources#ternjs#types = 1
let g:deoplete#sources#ternjs#docs = 1
" }

" TernForVim: {
let g:tern_show_signature_in_pum = 1
let g:tern#filetypes = [
                \ 'jsx',
                \ 'javascript.jsx',
                \ ]
" Make neocomplete understand that we are getting syntax info from tern
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.javascript =
  \ '\h\w*\|[^. \t]\.\w*'
" }

" VimGo: {
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.go =
  \ '\h\w*\|[^. \t]\.\w*'
if s:has_exec("goimports")
  let g:go_fmt_command = "goimports"
  if has("win32")
    let g:go_fmt_command = "goimports.exe"
  endif
endif
" }

" Echodoc:
let g:echodoc_enable_at_startup = 1

" AutoPairs: {
let s:autoPairsMapCh=0
let s:autoPairsMapBS=0
augroup VimrcRustAutopairs
  autocmd!
  autocmd FileType rust let g:AutoPairs = {'(':')', '[':']', '{':'}',
        \ '"':'"', '`':'`'}
augroup END
" }

" Endwise:
let g:endwise_no_mappings = 1

" Vim_LocalVimrc:
let g:localvimrc_persistent = 2

" BufKill:
let g:BufKillCreateMappings=0

" Characterize:
nmap gch <Plug>(characterize)

" Goyo: {
autocmd User GoyoEnter Limelight
autocmd User GoyoLeave Limelight!
" }

" Limelight:
let g:limelight_conceal_ctermfg = 'DarkGray'

" Vim Airline: {
if empty($SIMPLE_VIM_PLUGINS)
  if g:syntax_plugin == s:syntax_syntastic
    let g:airline#extensions#syntastic#enabled = 1
  elseif g:syntax_plugin == s:syntax_neomake
    let g:airline#extensions#neomake#enabled = 1
  endif
  " Show a list of files on the top of the screen
  let g:airline#extensions#tabline#enabled = 1
  " let g:airline#extensions#tabline#buffer_nr_show = 1
  let s:tablineBuffWidth = winwidth(0) / 5
  if s:tablineBuffWidth < 20
    let s:tablineBuffWidth = 20
  endif
  let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
  let g:airline#extensions#tabline#tab_nr_type = 2

  let g:airline#extensions#tabline#show_tab_type = 1

  " Set the theme to solarized
  if !exists('g:airline_theme')
    let g:airline_theme = 'solarized'
  endif
  " Use fancy fonts
  if g:autocomplete_plugin == s:autocomplete_ycm && $UPSTREAM_YCM == 0
    let g:airline_powerline_fonts = 0
  else
    let g:airline_powerline_fonts = 1
  endif

  " Only show git stats that are non-zero
  let g:airline#extensions#hunks#non_zero_only=1
  if s:has_exec('tmux')
    " Don't load tmuxline unless I decide to. It adds 1000ms to startuptime
    let g:airline#extensions#tmuxline#enabled=0
  endif
  " Clean up the status bar:
  " Just show the list of files/buffers in section c
  let g:airline_section_c = "%f%m %<%{bufname('#') != bufname('%') ? '('. bufname('#') .')' : ''}"
  " No need for tagbar if we don't have ctags. Also don't call functions if the plugin isn't " installed.
  if s:has_exec('ctags') && VimPlugInitialized == 1
    " No need to show filetype in the status bar, the ctags section is enough
    " autocmd User AirlineAfterInit let g:airline_section_y = airline#section#create(['tagbar'])
    let g:airline_section_y = airline#section#create(['tagbar'])
  endif
  " Also don't need to know the formatting. Just leave it empty
  let g:airline_section_x=''
  " Automatically refresh airline when changing colorschemes. This fixes the arrows.
  autocmd VimEnter * autocmd ColorScheme * AirlineRefresh
endif
" }

" VimTmuxNavigator: {
if has('nvim') && s:has_exec('tmux')
  " A hackey solution to C-h not working
  nnoremap <silent> <BS> :TmuxNavigateLeft<cr>
endif
" }

" Vim Fugitive: {
" Search the word under the cursor with `git grep`.
" Result locations are put into quickfix.
" https://statico.github.io/vim3.html
nmap <leader>gk :Ggrep! "\b<cword>\b" <CR>
" }

" Vim GitGutter: {
" Tell gitgutter not to set any keybinds by itself. They will all be rebound.
let g:gitgutter_map_keys = 0
if s:has_exec('git')
  " Move from to the next/prev change
  nmap ]g <Plug>GitGutterNextHunk
  nmap [g <Plug>GitGutterPrevHunk
  " Stage or revert the lines the cursor is on
  nmap <Leader>gs <Plug>GitGutterStageHunk
  nmap <Leader>gr <Plug>GitGutterRevertHunk
  " Preview the changes
  nmap <Leader>gp <Plug>GitGutterPreviewHunk
  let g:gitgutter_eager = 0

  " " Disable some things if the file is very large.
  " let g:LargeFile = 1024 * 1024 * 1
  " autocmd BufNew * let b:gitGutEnAu = 0
  " function! LargeFileGitgutter() abort
  "   let f=expand("<afile>")
  "   if getfsize(f) > g:LargeFile
  "     let g:gitgutter_enabled = 0
  "     let g:gitgutter_realtime = 0
  "     if b:gitGutEnAu == 0
  "       autocmd BufWritePost <buffer> :GitGutterEnable
  "     endif
  "     let b:gitGutEnAu = 1
  "   endif
  " endfunction
  " augroup LargeFile
  "   autocmd!
  "   " Gitgutter slows vim to a halt if the file is to big, so turn it off in those cases.
  "   autocmd BufReadPre * call LargeFileGitgutter()
  " augroup END
endif
" }

" Gutentags {
nnoremap <leader>gt :GutentagsUpdate<CR>
let g:gutentags_ctags_exclude = ['node_modules']
" }

" Solarized: {
let g:solarized_termcolors=256
let g:solarized_termtrans=1
let g:solarized_visibility='high'
" }

" Rainbow: {
let g:rainbow_active = 1
let g:rainbow_conf = {
\   'guifgs': ['#6c71c4', '#d33682', '#dc322f', '#cb4b16', '#b58900', '#859900', '#2aa198', '#268bd2'],
\   'ctermfgs': ['13', '5', '1', '9', '3', '2', '6', '4'],
\   'operators': '_,_',
\   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
\   'separately': {
\   }
\}
" }

" Tagbar: {
" Bind a button to open the tagbar
if s:has_exec('ctags')
  nnoremap <leader>cb :TagbarToggle<CR>
endif
let g:tagbar_autoclose=1
let g:tagbar_autofocus=1
" }

" UndoTree: {
" Bind a button to open UntoDree
nnoremap <leader>gu :UndotreeToggle<CR>
" }

" Indent Lines: {
let g:indentLine_enabled=0
" The default bind, just here so I remember
nnoremap <leader>ig :IndentLinesToggle<CR>
" }

" Easy Motion: {
" NOTE: omaps are used when using 'c' and 'd' operators
"nmap <leader> <Plug>(easymotion-prefix)
omap <leader> <Plug>(easymotion-prefix)
let g:EasyMotion_do_mapping = 0 " Disable default mappings
" Make some easymotion binds
nmap <leader>l <Plug>(easymotion-lineforward)
omap <leader>l <Plug>(easymotion-lineforward)
nmap <leader>h <Plug>(easymotion-linebackward)
omap <leader>h <Plug>(easymotion-linebackward)
nmap <leader>j <Plug>(easymotion-j)
omap <leader>j <Plug>(easymotion-j)
vmap <leader>j <Plug>(easymotion-j)
omap <leader>j <Plug>(easymotion-j)
nmap <leader>k <Plug>(easymotion-k)
omap <leader>k <Plug>(easymotion-k)
vmap <leader>k <Plug>(easymotion-k)
omap <leader>k <Plug>(easymotion-k)
nmap <leader>s <Plug>(easymotion-s2)
omap <leader>s <Plug>(easymotion-s2)
vmap <leader>s <Plug>(easymotion-s2)
omap <leader>s <Plug>(easymotion-s2)
let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion
" }

" W3m: {
if s:has_exec('w3m')
  " Bind w3m to an easy key and add http so it doesn't search.
  nnoremap <leader>w3 :W3m http://
  autocmd FileType w3m setlocal colorcolumn=
  autocmd FileType w3m setlocal scrolloff=3
  autocmd FileType w3m nnoremap <buffer>q :W3mClose<CR>
  autocmd FileType w3m nnoremap <buffer>o :W3mAddressBar<CR>
  " Shift j/k scrolls down/up
  autocmd FileType w3m nnoremap <buffer><S-j> <C-e>
  autocmd FileType w3m nnoremap <buffer><S-k> <C-y>
endif
" }

" FZF: {
let g:fzf_command_prefix="Fzf"
if s:has_exec('fzf')
  nmap <leader>p :FZF<CR>
  nmap <leader>b :FzfBuffers<CR>
  nmap <leader>t :FzfBTags<CR>
  autocmd FileType javascript command! -buffer -bang -nargs=* FzfBTags
    \ call fzf#vim#buffer_tags(<q-args>,
    \ [printf('jsctags %s -f', expand('%:S'))],
    \ <bang>0 ? {} : copy(get(g:, 'fzf_layout', g:fzf#vim#default_layout)))
      " \ printf('ctags -f - --sort=no --excmd=number --language-force=%s %s', &filetype, expand('%:S')),
      " \ printf('ctags -f - --sort=no --excmd=number %s', expand('%:S'))], {})
endif
" }

" Vimux: {
if s:has_exec('tmux')
  map <leader>vp :VimuxPromptCommand<CR>
  map <leader>vr :VimuxRunLastCommand<CR>
  map <leader>vo :VimuxInspectRunner<CR>
  map <leader>vc :VimuxCloseRunner<CR>
endif
" }

" PreserveNoEOL:
let g:PreserveNoEOL=1

" PIV: {
" Don't let it map, because it causes ',' to hava a delay
let g:PIVCreateDefaultMappings = 0
" AutoPHPFolding really hits performance, making cursor movement and switching bufers laggy
let g:DisableAutoPHPFolding = 1
" }

" TComment:
let g:tcommentGuessFileType_php = "php"

" JCommenter: {
" Set author config
augroup JCommenterSettings
  autocmd!
  autocmd FileType java let g:jcommenter_class_author='Adam Cutler'
  autocmd FileType java let g:jcommenter_file_author='Adam Cutler'
  autocmd FileType java let g:jcommenter_method_description_space = 1
  " Create a bind to generate comments
  autocmd FileType java nmap <leader>cj :call JCommentWriter()<CR>
  autocmd FileType java nmap <leader>c] :call SearchInvalidComment(0)<cr>
  autocmd FileType java nmap <leader>c[ :call SearchInvalidComment(1)<cr>
augroup END
" }

" VimJSDoc: {
let g:jsdoc_allow_input_prompt=1
let g:jsdoc_additional_descriptions=1
let g:jsdoc_default_mapping=0

augroup VIMJSDOC
  autocmd!
  autocmd FileType javascript nmap <leader>cj :JsDoc<CR>
augroup END
" }

" SyntaxAttr:
nmap <leader>a :call SyntaxAttr()<CR>

" VimPandoc: {
let g:pandoc#keyboard#use_default_mappings = 0
if s:has_exec('pandoc')
  augroup PandocBinds
    autocmd!
    autocmd FileType pandoc nmap <buffer>go <Plug>(pandoc-keyboard-links-open)
    autocmd FileType pandoc nmap <buffer>gb <Plug>(pandoc-keyboard-links-back)
  augroup END
endif
" }

" VimPandocSyntax: {
if !s:has_exec('pandoc')
  augroup pandoc_syntax
    autocmd!
    autocmd BufNewFile,BufFilePre,BufRead *.pdc set filetype=pandoc
    autocmd BufNewFile,BufFilePre,BufRead *.md set filetype=markdown.pandoc
augroup END
endif
" }

" VimOperatorSurround: {
" operator mappings
map <silent>sa <Plug>(operator-surround-append)
map <silent>sd <Plug>(operator-surround-delete)
map <silent>sc <Plug>(operator-surround-replace)
" }

" VimOperatorReplace:
map <silent><leader>re <Plug>(operator-replace)

" TextobjComment: {
let g:textobj_comment_no_default_key_mappings = 1
xmap ax <Plug>(textobj-comment-a)
omap ax <Plug>(textobj-comment-a)
xmap ix <Plug>(textobj-comment-i)
omap ix <Plug>(textobj-comment-i)
xmap aX <Plug>(textobj-comment-big-a)
omap aX <Plug>(textobj-comment-big-a)
xmap iX <Plug>(textobj-comment-big-i)
omap iX <Plug>(textobj-comment-big-i)
" }

" Custom operator comment (UNUSED) {
" Using vim-operator-user (With NERDCommenter)
" http://relaxedcolumn.blog8.fc2.com/blog-entry-154.html
" Get SID prefix of vimrc (see :h <SID>)
" function! s:SID_PREFIX() abort
"     return matchstr(expand('<sfile>'), '<SNR>\d\+_')
" endfunction
"function! s:setCommentOperator(key, name) abort
    "call operator#user#define(
    "\   'comment-' . a:name,
    "\   s:SID_PREFIX() . 'doCommentCommand',
    "\   'call ' . s:SID_PREFIX() . 'setCommentCommand("' . a:name . '")')
    "execute 'map' a:key '<Plug>(operator-comment-' . a:name . ')'
"endfunction

"function! s:setCommentCommand(command) abort
    "let s:comment_command = a:command
"endfunction

"function! s:doCommentCommand(motion_wiseness) abort
    "let v = operator#user#visual_command_from_wise_name(a:motion_wiseness)
    "execute 'normal! `[' . v . "`]\<Esc>"
    "echo s:comment_command
    "call NERDComment('x', s:comment_command)
"endfunction

"call s:setCommentOperator('<leader>cv', 'comment')
"call s:setCommentOperator('<leader>cx', 'uncomment')
" }

" }


" Chained Keybinds: {
" Sometimes multiple plugins want to use the same key, or mapping them in
" a certain order causes things act funny.
" This section is for mapping those cases.

" Enter: {
" Deoplete:
if empty($SIMPLE_VIM_PLUGINS)
  if has('nvim')
    imap <silent><CR> <C-r>=<SID>my_cr_function()<CR>

    " Close the completion popup if it is visible. If it is not, press Enter.
    function! s:my_cr_function() abort
      let cr_str = pumvisible() ? "" : "\<CR>"
      return deoplete#close_popup() . cr_str
      " return (pumvisible() ? "\<C-y>" : "" ) . "\<Plug>AutoPairsReturn"
    endfunction

  " Neocomplete:
  else
    imap <silent><CR> <C-r>=<SID>my_cr_function()<CR>

    function! s:my_cr_function() abort
      let cr_str = pumvisible() ? "" : "\<CR>"
      return neocomplete#close_popup() . cr_str
    endfunction
  endif
endif

" Make sure that <CR> at least has itself in the mapping
if !mapcheck('<CR>', 'i')
  imap <silent><CR> <CR>
endif

" Endwise:
exe "imap <silent><CR> ".maparg('<CR>','i')."<Plug>DiscretionaryEnd"
" }

" CtrlH: {
" Deoplete:
if empty($SIMPLE_VIM_PLUGINS)
  if has('nvim')
    imap <silent><C-h> <C-r>=deoplete#smart_close_popup()<CR>

  " Neocomplete:
  else
    imap <silent><C-h> <C-r>=neocomplete#smart_close_popup()<CR>
  endif
endif

" Make sure that <c-h> at least has itself in the mapping
if !mapcheck('<c-h>', 'i')
  imap <silent><c-h> <c-h>
endif
" AutoPairs:
exe "imap <silent><C-h> ".maparg('<C-h>', 'i')."<C-r>=AutoPairsDelete()<CR>"
" }

" Backspace: {
" Deoplete:
if empty($SIMPLE_VIM_PLUGINS)
  if has('nvim')
    imap <silent><BS> <C-r>=deoplete#smart_close_popup()<CR>

  " Neocomplete:
  else
    imap <silent><BS> <C-r>=neocomplete#smart_close_popup()<CR>
  endif
endif

" Make sure that <BS> at least has itself in the mapping
if !mapcheck('<BS>', 'i')
  imap <silent><BS> <BS>
endif
" AutoPairs:
exe "imap <silent><BS> ".maparg('<BS>', 'i')."<C-r>=AutoPairsDelete()<CR>"
" }
" }

" vim: foldmethod=marker foldmarker={,}
